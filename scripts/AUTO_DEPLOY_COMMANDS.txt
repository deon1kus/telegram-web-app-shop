cd /root/telegram-bot && mkdir -p routes/telegram utils/telegram && cat > full-deploy.sh << 'DEPLOY_EOF'
#!/bin/bash
set -e
PROJECT_DIR="/root/telegram-bot"
cd "$PROJECT_DIR"
echo "üöÄ –ù–∞—á–∞–ª–æ –ø–æ–ª–Ω–æ–≥–æ —Ä–∞–∑–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏—è webhook..."
echo ""
echo "üìÅ –®–∞–≥ 1: –°–æ–∑–¥–∞–Ω–∏–µ –¥–∏—Ä–µ–∫—Ç–æ—Ä–∏–π..."
mkdir -p routes/telegram
mkdir -p utils/telegram
echo "‚úÖ –î–∏—Ä–µ–∫—Ç–æ—Ä–∏–∏ —Å–æ–∑–¥–∞–Ω—ã"
echo ""
echo "üìù –®–∞–≥ 2: –°–æ–∑–¥–∞–Ω–∏–µ —Ñ–∞–π–ª–æ–≤ webhook..."
cat > utils/telegram/parser.js << 'PARSER_EOF'
function parseProductMessage(message) {
  if (!message) return null;
  const result = { messageId: message.message_id || message.messageId };
  const text = message.caption || message.text || '';
  if (!text && !message.photo) return null;
  if (message.photo && Array.isArray(message.photo) && message.photo.length > 0) {
    const largestPhoto = message.photo[message.photo.length - 1];
    result.photoFileId = largestPhoto.file_id;
  }
  const descriptionMatch = text.match(/üìù\s*(.+?)(?=\n(?:üí∞|üì¶|üè∑Ô∏è|üìû|#)|$)/s);
  if (descriptionMatch) {
    result.description = descriptionMatch[1].trim();
  } else {
    const firstMarker = text.match(/(üí∞|üì¶|üè∑Ô∏è|üìû|#)/);
    if (firstMarker) {
      result.description = text.substring(0, firstMarker.index).trim();
    } else {
      result.description = text.trim();
    }
  }
  const priceMatch = text.match(/üí∞\s*–¶–µ–Ω–∞:\s*(\d+(?:\s*\d+)*)\s*—Ç–æ–º–∞–Ω/i);
  if (priceMatch) {
    const priceStr = priceMatch[1].replace(/\s+/g, '');
    result.price = parseInt(priceStr, 10);
  }
  const quantityMatch = text.match(/üì¶\s*–ö–æ–ª–∏—á–µ—Å—Ç–≤–æ:\s*(\d+)\s*—à—Ç/i);
  if (quantityMatch) {
    result.quantity = parseInt(quantityMatch[1], 10);
  }
  const categoryMatch = text.match(/üè∑Ô∏è\s*–ö–∞—Ç–µ–≥–æ—Ä–∏—è:\s*(.+?)(?=\n|$)/i);
  if (categoryMatch) {
    result.category = categoryMatch[1].trim();
  }
  const contactMatch = text.match(/üìû\s*–ö–æ–Ω—Ç–∞–∫—Ç:\s*(.+?)(?=\n|$)/i);
  if (contactMatch) {
    result.contact = contactMatch[1].trim();
  }
  const productIdMatch = text.match(/#product_id[:\s]*(\d+)/i);
  if (productIdMatch) {
    result.productId = productIdMatch[1];
  }
  return result;
}
function validateParsedProduct(parsed) {
  if (!parsed.description || !parsed.price) return false;
  if (parsed.price <= 0) return false;
  if (parsed.quantity !== undefined && parsed.quantity < 0) return false;
  return true;
}
function addProductIdToMessage(text, productId) {
  const cleaned = text.replace(/\n?#product_id[:\s]*\d+\s*/gi, '');
  return cleaned.trim() + '\n\n#product_id:' + productId;
}
function generateMessageLink(channelId, messageId) {
  const channelIdStr = channelId.toString().replace(/^-100/, '');
  return `https://t.me/c/${channelIdStr}/${messageId}`;
}
module.exports = { parseProductMessage, validateParsedProduct, addProductIdToMessage, generateMessageLink };
PARSER_EOF
cat > utils/telegram/api.js << 'API_EOF'
const axios = require('axios');
const BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN;
const TELEGRAM_API = `https://api.telegram.org/bot${BOT_TOKEN}`;
async function downloadPhotoFromTelegram(photoFileId) {
  try {
    const fileResponse = await axios.get(`${TELEGRAM_API}/getFile`, { params: { file_id: photoFileId } });
    const filePath = fileResponse.data.result.file_path;
    return `https://api.telegram.org/file/bot${BOT_TOKEN}/${filePath}`;
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –∑–∞–≥—Ä—É–∑–∫–∏ —Ñ–æ—Ç–æ:', error);
    return null;
  }
}
async function editMessageCaption(channelId, messageId, caption) {
  try {
    const response = await axios.post(`${TELEGRAM_API}/editMessageCaption`, { chat_id: channelId, message_id: messageId, caption: caption });
    return response.data.ok;
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è —Å–æ–æ–±—â–µ–Ω–∏—è:', error);
    return false;
  }
}
async function sendMessage(chatId, text, options = {}) {
  try {
    const response = await axios.post(`${TELEGRAM_API}/sendMessage`, { chat_id: chatId, text: text, parse_mode: 'Markdown', disable_web_page_preview: false, ...options });
    return response.data.ok ? response.data.result : null;
  } catch (error) {
    console.error('–û—à–∏–±–∫–∞ –æ—Ç–ø—Ä–∞–≤–∫–∏ —Å–æ–æ–±—â–µ–Ω–∏—è:', error);
    return null;
  }
}
module.exports = { downloadPhotoFromTelegram, editMessageCaption, sendMessage };
API_EOF
cat > utils/telegram/notifications.js << 'NOTIF_EOF'
const { sendMessage } = require('./api');
const { generateMessageLink } = require('./parser');
const NOTIFICATIONS_CHANNEL_ID = process.env.NOTIFICATIONS_CHANNEL_ID || '-1003018207910';
function formatNewProductNotification(productName, productId, messageLink) {
  return `üÜï –ù–æ–≤—ã–π —Ç–æ–≤–∞—Ä #${productId}\n\nüì¶ ${productName}\n\nüîó ${messageLink}`;
}
async function sendNewProductNotification(productName, productId, channelId, messageId) {
  const messageLink = generateMessageLink(channelId, messageId);
  const text = formatNewProductNotification(productName, productId, messageLink);
  return await sendMessage(NOTIFICATIONS_CHANNEL_ID, text);
}
module.exports = { formatNewProductNotification, sendNewProductNotification };
NOTIF_EOF
cat > routes/telegram/webhook.js << 'WEBHOOK_EOF'
const express = require('express');
const router = express.Router();
const { parseProductMessage, validateParsedProduct, addProductIdToMessage, generateMessageLink } = require('../../utils/telegram/parser');
const { editMessageCaption, downloadPhotoFromTelegram } = require('../../utils/telegram/api');
const { sendNewProductNotification } = require('../../utils/telegram/notifications');
const PRODUCTS_CHANNEL_ID = process.env.PRODUCTS_CHANNEL_ID || '-1003271699368';
const NOTIFICATIONS_CHANNEL_ID = process.env.NOTIFICATIONS_CHANNEL_ID || '-1003018207910';
async function getNextProductSequenceId() {
  return Math.floor(Math.random() * 1000) + 1;
}
async function createProductFromTelegram(data) {
  console.log('–°–æ–∑–¥–∞–Ω–∏–µ —Ç–æ–≤–∞—Ä–∞:', data);
  return { product_Id: 1, product_sequence_id: data.productSequenceId };
}
async function findCategoryByName(categoryName) {
  return null;
}
router.post('/webhook', async (req, res) => {
  try {
    const { channel_post, edited_channel_post } = req.body;
    const message = channel_post || edited_channel_post;
    if (!message || message.chat?.id?.toString() !== PRODUCTS_CHANNEL_ID.replace('-100', '')) {
      return res.status(200).json({ ok: true });
    }
    console.log('–ü–æ–ª—É—á–µ–Ω–æ —Å–æ–æ–±—â–µ–Ω–∏–µ –∏–∑ –∫–∞–Ω–∞–ª–∞:', message.message_id);
    const parsed = parseProductMessage(message);
    if (!parsed || !validateParsedProduct(parsed)) {
      console.log('–°–æ–æ–±—â–µ–Ω–∏–µ –Ω–µ —è–≤–ª—è–µ—Ç—Å—è —Ç–æ–≤–∞—Ä–æ–º –∏–ª–∏ –Ω–µ–≤–∞–ª–∏–¥–Ω–æ');
      return res.status(200).json({ ok: true });
    }
    console.log('–†–∞—Å–ø–∞—Ä—Å–µ–Ω–Ω—ã–µ –¥–∞–Ω–Ω—ã–µ:', parsed);
    let categoryIds = [];
    if (parsed.category) {
      const category = await findCategoryByName(parsed.category);
      if (category) {
        categoryIds = [category.category_Id || category.id];
      }
    }
    let photoUrl = null;
    if (parsed.photoFileId) {
      photoUrl = await downloadPhotoFromTelegram(parsed.photoFileId);
      console.log('–§–æ—Ç–æ –∑–∞–≥—Ä—É–∂–µ–Ω–æ:', photoUrl);
    }
    const adminUserId = process.env.ADMIN_USER_ID || process.env.ADMIN_CHAT_ID || '1';
    if (channel_post && !parsed.productId) {
      console.log('–°–æ–∑–¥–∞–Ω–∏–µ –Ω–æ–≤–æ–≥–æ —Ç–æ–≤–∞—Ä–∞...');
      const productSequenceId = await getNextProductSequenceId();
      const product = await createProductFromTelegram({
        description: parsed.description,
        price: parsed.price,
        quantity: parsed.quantity || 0,
        categoryIds: categoryIds,
        photoUrl: photoUrl,
        photoFileId: parsed.photoFileId,
        userId: adminUserId,
        messageId: parsed.messageId,
        productSequenceId: productSequenceId,
        category: parsed.category,
        contact: parsed.contact
      });
      if (product) {
        const currentCaption = message.caption || message.text || '';
        const updatedCaption = addProductIdToMessage(currentCaption, productSequenceId);
        await editMessageCaption(PRODUCTS_CHANNEL_ID, message.message_id, updatedCaption);
        console.log('–°–æ–æ–±—â–µ–Ω–∏–µ –æ–±–Ω–æ–≤–ª–µ–Ω–æ —Å product_id:', productSequenceId);
        await sendNewProductNotification(parsed.description, productSequenceId, PRODUCTS_CHANNEL_ID, message.message_id);
        console.log('–£–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ');
      }
    }
    res.status(200).json({ ok: true });
  } catch (error) {
    console.error('Webhook error:', error);
    res.status(200).json({ ok: true });
  }
});
module.exports = router;
WEBHOOK_EOF
echo "‚úÖ –§–∞–π–ª—ã —Å–æ–∑–¥–∞–Ω—ã"
echo ""
echo "üîê –®–∞–≥ 3: –ü—Ä–æ–≤–µ—Ä–∫–∞ –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö –æ–∫—Ä—É–∂–µ–Ω–∏—è..."
if [ ! -f ".env" ]; then
    cat > .env << EOF
TELEGRAM_BOT_TOKEN=7811866862:AAH4z4mpba_o-fRCdgDv09Ej8nTy-QkzId8
PRODUCTS_CHANNEL_ID=-1003271699368
NOTIFICATIONS_CHANNEL_ID=-1003018207910
ADMIN_USER_ID=1
API_URL=http://194.87.0.193
EOF
fi
if ! grep -q "PRODUCTS_CHANNEL_ID" .env; then
    echo "PRODUCTS_CHANNEL_ID=-1003271699368" >> .env
fi
if ! grep -q "NOTIFICATIONS_CHANNEL_ID" .env; then
    echo "NOTIFICATIONS_CHANNEL_ID=-1003018207910" >> .env
fi
echo "‚úÖ –ü–µ—Ä–µ–º–µ–Ω–Ω—ã–µ –æ–∫—Ä—É–∂–µ–Ω–∏—è –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã"
echo ""
echo "üîç –®–∞–≥ 4: –ü–æ–∏—Å–∫ –≥–ª–∞–≤–Ω–æ–≥–æ —Ñ–∞–π–ª–∞ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏—è..."
MAIN_FILE=""
for file in app.js server.js index.js main.js; do
    if [ -f "$file" ]; then
        MAIN_FILE="$file"
        echo "‚úÖ –ù–∞–π–¥–µ–Ω –≥–ª–∞–≤–Ω—ã–π —Ñ–∞–π–ª: $file"
        break
    fi
done
if [ -z "$MAIN_FILE" ]; then
    echo "‚ö†Ô∏è  –ì–ª–∞–≤–Ω—ã–π —Ñ–∞–π–ª –Ω–µ –Ω–∞–π–¥–µ–Ω. –ù—É–∂–Ω–æ –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞—Ç—å —Ä–æ—É—Ç –≤—Ä—É—á–Ω—É—é."
else
    if grep -q "telegram/webhook" "$MAIN_FILE"; then
        echo "‚úÖ –†–æ—É—Ç —É–∂–µ –∏–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞–Ω"
    else
        echo "‚ö†Ô∏è  –ù—É–∂–Ω–æ –¥–æ–±–∞–≤–∏—Ç—å –≤ $MAIN_FILE:"
        echo "   const telegramWebhookRouter = require('./routes/telegram/webhook');"
        echo "   app.use('/api/telegram', telegramWebhookRouter);"
    fi
fi
echo ""
echo "‚úÖ –†–∞–∑–≤–µ—Ä—Ç—ã–≤–∞–Ω–∏–µ —Ñ–∞–π–ª–æ–≤ –∑–∞–≤–µ—Ä—à–µ–Ω–æ!"
echo ""
echo "‚ö†Ô∏è  –°–ª–µ–¥—É—é—â–∏–µ —à–∞–≥–∏:"
echo "1. –ò–Ω—Ç–µ–≥—Ä–∏—Ä–æ–≤–∞—Ç—å —Ä–æ—É—Ç –≤ –≥–ª–∞–≤–Ω—ã–π —Ñ–∞–π–ª"
echo "2. –†–µ–∞–ª–∏–∑–æ–≤–∞—Ç—å —Ñ—É–Ω–∫—Ü–∏–∏ –ë–î"
echo "3. –û–±–Ω–æ–≤–∏—Ç—å –±–∞–∑—É –¥–∞–Ω–Ω—ã—Ö"
echo "4. –ù–∞—Å—Ç—Ä–æ–∏—Ç—å SSL –¥–ª—è HTTPS"
echo "5. –ù–∞—Å—Ç—Ä–æ–∏—Ç—å webhook –≤ Telegram"
DEPLOY_EOF
chmod +x full-deploy.sh
./full-deploy.sh
